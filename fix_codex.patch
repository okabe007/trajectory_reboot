diff --git a/spermsim/main.py b/spermsim/main.py
index aa6bc55..8d265d1 100644
--- a/spermsim/main.py
+++ b/spermsim/main.py
@@ -890,73 +890,68 @@ def IO_check_spot(base_position, temp_position, constants, IO_status, stick_stat
     xy_dist = np.sqrt(temp_position[0] ** 2 + temp_position[1] ** 2)
 
     if z_tip > bottom_z + limit:
         if r_tip > radius + limit:
             return IOStatus.SPHERE_OUT
         if r_tip < radius - limit:
             return IOStatus.TEMP_ON_POLYGON if stick_status > 0 else IOStatus.INSIDE
 
         if _depth == 0:
             scaled = base_position + (temp_position - base_position) * 1.2
             return IO_check_spot(base_position, scaled, constants, IO_status, stick_status, _depth=1)
         return IOStatus.INSIDE
 
     if z_tip < bottom_z - limit:
         denom = temp_position[2] - base_position[2]
         t = (bottom_z - base_position[2]) / denom
         if t < 0 or t > 1:
             return IOStatus.SPHERE_OUT
         intersect_xy = base_position[:2] + t * (temp_position[:2] - base_position[:2])
         dist_xy = np.sqrt(intersect_xy[0] ** 2 + intersect_xy[1] ** 2)
         if dist_xy < bottom_r + limit:
             return IOStatus.BOTTOM_OUT
         return IOStatus.SPHERE_OUT
 
     if bottom_z - limit < z_tip < bottom_z + limit:
-        if xy_dist > bottom_r + limit:
-            return IOStatus.SPOT_EDGE_OUT
-
-        if abs(xy_dist - bottom_r) <= limit:
-            base_xy = np.sqrt(base_position[0] ** 2 + base_position[1] ** 2)
-            base_on_border = (
-                abs(base_position[2] - bottom_z) <= limit and abs(base_xy - bottom_r) <= limit
-            )
-            if base_on_border:
-                if IO_status == IOStatus.POLYGON_MODE:
-                    return IOStatus.POLYGON_MODE
-                return IOStatus.SPOT_BOTTOM if xy_dist < bottom_r else IOStatus.SPOT_EDGE_OUT
-
+        base_xy = np.sqrt(base_position[0] ** 2 + base_position[1] ** 2)
+        start_on_border = (
+            abs(base_position[2] - bottom_z) <= limit and abs(base_xy - bottom_r) <= limit
+        )
+        if start_on_border:
+            if IO_status == IOStatus.POLYGON_MODE:
+                return IOStatus.POLYGON_MODE
+            if xy_dist < bottom_r - limit:
+                return IOStatus.SPOT_BOTTOM
+            if xy_dist > bottom_r + limit:
+                return IOStatus.SPOT_EDGE_OUT
+            return IOStatus.SPOT_BOTTOM if xy_dist < bottom_r else IOStatus.SPOT_EDGE_OUT
+        else:
             if _depth == 0:
                 scaled = base_position + (temp_position - base_position) * 1.2
                 return IO_check_spot(base_position, scaled, constants, IO_status, stick_status, _depth=1)
             return IOStatus.INSIDE
 
-        if xy_dist < bottom_r - limit:
-            if IO_status in [IOStatus.SPOT_EDGE_OUT, IOStatus.POLYGON_MODE] or stick_status > 0:
-                return IOStatus.POLYGON_MODE
-            return IOStatus.SPOT_BOTTOM
-
     return IOStatus.INSIDE
 class SpermSimulation:
     def initialize_thickness(self):
         for j in range(self.number_of_sperm):
             for i in range(self.number_of_steps):
                 self.vec_thickness_2d[j, i] = 0.4
                 self.vec_thickness_3d[j, i] = 1.5
 
     
     def __init__(self, constants, visualizer, simulation_data):
 
         self.constants = constants  # ✅ 最初に設定
 
         self.number_of_sperm = self.constants["number_of_sperm"]
         self.number_of_steps = self.constants["number_of_steps"]
 
         self.vec_thickness_2d = np.zeros((self.number_of_sperm, self.number_of_steps))
         self.vec_thickness_3d = np.zeros((self.number_of_sperm, self.number_of_steps))
         self.initialize_thickness()
 
         self.visualizer = visualizer
         self.simulation = simulation_data
         self.n_stop = self.constants.get('n_stop', 0)
 
         if constants.get('reflection_analysis', 'no') == "yes":
