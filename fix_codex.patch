diff --git a/core/simulation.py b/core/simulation.py
index 2133aa7..ba6a484 100644
--- a/core/simulation.py
+++ b/core/simulation.py
@@ -105,101 +105,179 @@ def _io_check_drop(
         return "inside"
 
     # Near the border, extend the vector from ``base_position``
     # to ``position`` and re-evaluate.
     vector = position - base_position
     extended_position = base_position + vector * 1.2
     extended_dist = np.linalg.norm(extended_position)
 
     if extended_dist <= r:
         return "inside"
     return "outside"
 
 
 class SpotIO:
     """Status constants for spot geometry."""
 
     INSIDE = "inside"
     BORDER = "border"
     SPHERE_OUT = "sphere_out"
     BOTTOM_OUT = "bottom_out"
     SPOT_EDGE_OUT = "spot_edge_out"
     POLYGON_MODE = "polygon_mode"
     SPOT_BOTTOM = "spot_bottom"
 
 
-def _io_check_spot(
+def _spot_status_check(
     base_position: np.ndarray,
     temp_position: np.ndarray,
     constants: dict,
     prev_stat: str = "inside",
     stick_status: int = 0,
 ) -> str:
-    """Return detailed IO status for spot shape."""
+    """Return IO status for spot shape without modifying the position."""
 
     radius = constants.get("spot_r", constants.get("radius", 0.0))
     bottom_z = constants.get("spot_bottom_height", 0.0)
     bottom_r = constants.get("spot_bottom_r", 0.0)
     limit = constants.get("limit", 1e-9)
 
     z_tip = temp_position[2]
     r_tip = np.linalg.norm(temp_position)
     xy_dist = np.linalg.norm(temp_position[:2])
 
     if z_tip > bottom_z + limit:
         if r_tip > radius + limit:
             return SpotIO.SPHERE_OUT
         if r_tip < radius - limit:
             return SpotIO.POLYGON_MODE if stick_status > 0 else SpotIO.INSIDE
         return SpotIO.BORDER
 
     if z_tip < bottom_z - limit:
         denom = temp_position[2] - base_position[2]
         if abs(denom) < limit:
             return SpotIO.SPHERE_OUT
         t = (bottom_z - base_position[2]) / denom
         if t < 0 or t > 1:
             return SpotIO.SPHERE_OUT
         intersect_xy = base_position[:2] + t * (temp_position[:2] - base_position[:2])
         dist_xy = np.linalg.norm(intersect_xy)
         if dist_xy < bottom_r + limit:
             return SpotIO.BOTTOM_OUT
         return SpotIO.SPHERE_OUT
 
     if bottom_z - limit < z_tip < bottom_z + limit:
         if xy_dist > bottom_r + limit:
             return SpotIO.SPOT_EDGE_OUT
         if abs(xy_dist - bottom_r) <= limit:
             return SpotIO.BORDER
         if xy_dist < bottom_r - limit:
             if prev_stat in (SpotIO.SPOT_EDGE_OUT, SpotIO.POLYGON_MODE) or stick_status > 0:
                 return SpotIO.POLYGON_MODE
             return SpotIO.SPOT_BOTTOM
 
     return SpotIO.INSIDE
 
 
+def _io_check_spot(
+    base_position: np.ndarray,
+    temp_position: np.ndarray,
+    constants: dict,
+    prev_stat: str = "inside",
+    stick_status: int = 0,
+) -> tuple[np.ndarray, str, bool]:
+    """Return corrected position, final status and bottom hit flag.
+
+    The candidate position is repeatedly adjusted whenever it exits the
+    spherical cap so that the returned position lies inside.  If the
+    trajectory hits the bottom plane during this process ``bottom_hit`` is
+    set to ``True``.
+    """
+
+    candidate = temp_position.copy()
+    pos = base_position.copy()
+    status = _spot_status_check(pos, candidate, constants, prev_stat, stick_status)
+    bottom_hit = False
+
+    step_vec = candidate - pos
+    step_len = np.linalg.norm(step_vec)
+    if step_len < 1e-12:
+        return candidate, status, bottom_hit
+    vec = step_vec / step_len
+
+    for _ in range(10):
+        if status in (
+            SpotIO.INSIDE,
+            SpotIO.BORDER,
+            SpotIO.SPOT_BOTTOM,
+            SpotIO.POLYGON_MODE,
+        ):
+            break
+
+        if status in (SpotIO.SPHERE_OUT, SpotIO.SPOT_EDGE_OUT):
+            intersect, remain = _line_sphere_intersection(pos, candidate, constants["spot_r"])
+            normal = intersect / (np.linalg.norm(intersect) + 1e-12)
+            vec = _reflect(vec, normal)
+            pos = intersect
+            step_len = remain
+            candidate = pos + vec * step_len
+
+        elif status == SpotIO.BOTTOM_OUT:
+            bottom_hit = True
+            bottom_z = constants.get("spot_bottom_height", 0.0)
+            step_vec = candidate - pos
+            if abs(step_vec[2]) < 1e-12:
+                proj = step_vec.copy()
+                proj[2] = 0.0
+                norm = np.linalg.norm(proj)
+                if norm < 1e-12:
+                    proj = np.array([1.0, 0.0, 0.0]) * step_len
+                    norm = step_len
+                vec = proj / norm
+                candidate = pos + vec * step_len
+            else:
+                t = (bottom_z - pos[2]) / step_vec[2]
+                t = max(0.0, min(1.0, t))
+                intersect = pos + step_vec * t
+                remain = step_len * (1.0 - t)
+                proj_dir = vec.copy()
+                proj_dir[2] = 0.0
+                norm = np.linalg.norm(proj_dir)
+                if norm < 1e-12:
+                    proj_dir = np.array([1.0, 0.0, 0.0])
+                    norm = 1.0
+                proj_dir /= norm
+                pos = intersect
+                vec = proj_dir
+                step_len = remain
+                candidate = pos + vec * step_len
+
+        status = _spot_status_check(pos, candidate, constants, prev_stat, stick_status)
+
+    return candidate, status, bottom_hit
+
+
 def _line_sphere_intersection(p0: np.ndarray, p1: np.ndarray, r: float) -> tuple[np.ndarray, float]:
     """Return intersection point and remaining distance after hitting the sphere."""
     d = p1 - p0
     d_norm = np.linalg.norm(d)
     if d_norm < 1e-12:
         return p0.copy(), 0.0
     d_unit = d / d_norm
     f = p0
     a = 1.0
     b = 2.0 * float(f @ d_unit)
     c = float(f @ f) - r * r
     disc = b * b - 4 * a * c
     if disc < 0:
         return p0.copy(), 0.0
     sqrt_disc = math.sqrt(disc)
     t1 = (-b - sqrt_disc) / (2 * a)
     t2 = (-b + sqrt_disc) / (2 * a)
     # Only intersections that lie on the segment between ``p0`` and ``p1``
     # are valid.  Without this check ``t`` may point to an intersection far
     # away from the current step which leads to an excessively long vector.
     t_candidates = [t for t in (t1, t2) if 0 <= t <= d_norm]
     if not t_candidates:
         return p0.copy(), 0.0
     t = min(t_candidates)
     intersection = p0 + d_unit * t
diff --git a/core/simulation.py b/core/simulation.py
index 2133aa7..ba6a484 100644
--- a/core/simulation.py
+++ b/core/simulation.py
@@ -390,90 +468,61 @@ class SpermSimulation:
                         if status == "bottom":
                             step_vec = vec * move_len
                             if abs(step_vec[2]) < 1e-12:
                                 normal = np.array([0.0, 0.0, 1.0])
                                 vec = _reflect(vec, normal)
                                 candidate = base_pos + vec * move_len
                             else:
                                 t = (0.0 - base_pos[2]) / step_vec[2]
                                 t = max(0.0, min(1.0, t))
                                 intersect = base_pos + step_vec * t
                                 remain = move_len * (1.0 - t)
                                 normal = np.array([0.0, 0.0, 1.0])
                                 vec = _reflect(vec, normal)
                                 base_pos = intersect
                                 candidate = base_pos + vec * remain
                             status = _io_check_drop(candidate, self.constants, base_pos)
                         if status == "outside":
                             intersect, remain = _line_sphere_intersection(
                                 base_pos, candidate, self.constants["drop_r"]
                             )
                             normal = intersect / (np.linalg.norm(intersect) + 1e-12)
                             vec = _reflect(vec, normal)
                             candidate = intersect + vec * remain
                     elif shape == "spot":
                         prev = prev_states[i]
-                        status = _io_check_spot(pos, candidate, self.constants, prev)
-                        if status == SpotIO.SPHERE_OUT or status == SpotIO.SPOT_EDGE_OUT:
-                            intersect, remain = _line_sphere_intersection(
-                                pos, candidate, self.constants["spot_r"]
-                            )
-                            normal = intersect / (np.linalg.norm(intersect) + 1e-12)
-                            vec = _reflect(vec, normal)
-                            candidate = intersect + vec * remain
-                        elif status == SpotIO.BOTTOM_OUT:
+                        candidate, status, bottom_hit = _io_check_spot(
+                            pos, candidate, self.constants, prev, stick_statuses[i]
+                        )
+                        vec = (candidate - pos) / step_len
+                        if bottom_hit:
                             bottom_modes[i] = True
                             if stick_statuses[i] == 0:
                                 stick_statuses[i] = int(
                                     self.constants["surface_time"]
                                     / self.constants["sampl_rate_hz"]
                                 )
-                            bottom_z = self.constants["spot_bottom_height"]
-                            step_vec = vec * step_len
-                            if abs(step_vec[2]) < 1e-12:
-                                proj = step_vec.copy()
-                                proj[2] = 0.0
-                                norm = np.linalg.norm(proj)
-                                if norm < 1e-12:
-                                    proj = np.array([1.0, 0.0, 0.0]) * step_len
-                                    norm = step_len
-                                candidate = pos + proj / norm * step_len
-                                vec = proj / norm
-                            else:
-                                t = (bottom_z - pos[2]) / step_vec[2]
-                                t = max(0.0, min(1.0, t))
-                                intersect = pos + step_vec * t
-                                remain = step_len * (1.0 - t)
-                                proj_dir = vec.copy()
-                                proj_dir[2] = 0.0
-                                norm = np.linalg.norm(proj_dir)
-                                if norm < 1e-12:
-                                    proj_dir = np.array([1.0, 0.0, 0.0])
-                                    norm = 1.0
-                                proj_dir /= norm
-                                candidate = intersect + proj_dir * remain
-                                vec = (candidate - pos) / step_len
 
                     disp_len = np.linalg.norm(candidate - pos)
                     max_len = step_len
                     if disp_len > max_len * 1.05:
                         print(
                             f"[ERROR] displacement {disp_len} mm exceeds "
                             f"step_length {max_len} mm at rep={rep}, sperm={i}, step={j}"
                         )
                         print(f"pos={pos}, candidate={candidate}, vec={vec}")
                         raise RuntimeError("step length exceeded")
 
                     pos = candidate
                     traj.append(pos.copy())
                     if shape == "spot":
                         prev_states[i] = status
                         if bottom_modes[i]:
                             if stick_statuses[i] > 0:
                                 stick_statuses[i] -= 1
                             if stick_statuses[i] == 0:
                                 bottom_modes[i] = False
 
                     if rep == 0 and i == 0 and j == 0:
                         print(f"[DEBUG] 1step_disp(mm) = {np.linalg.norm(vec*step_len):.5f}")
 
                 self.trajectory.append(np.vstack(traj))
