diff --git a/spermsim/main.py b/spermsim/main.py
index 6787d74..89b008b 100644
--- a/spermsim/main.py
+++ b/spermsim/main.py
@@ -1316,88 +1316,88 @@ class SpermSimulation:
                 continue
             elif IO_status == IOStatus.POLYGON_MODE:
                 self.trajectory[j, i] = temp_position
                 base_position = self.trajectory[j, i]
                 if len(intersection_point) != 0:
                     last_vec = temp_position - intersection_point
                     intersection_point = np.array([])
                 else:
                     last_vec = self.trajectory[j, i] - self.trajectory[j, i - 1]
                 if shape == "drop":
                     new_temp_position, new_last_vec, updated_stick, next_state = self.drop_polygon_move(
                         base_position, last_vec, stick_status, constants
                     )
                 else:
                     new_temp_position, new_last_vec, updated_stick, next_state = self.bottom_edge_mode(
                         base_position, last_vec, stick_status, constants
                     )
                 temp_position = new_temp_position
                 last_vec = new_last_vec
                 stick_status = updated_stick
                 i += 1
                 IO_status = next_state
                 continue
             elif IO_status == IOStatus.SPOT_EDGE_OUT:
                 if stick_status == 0:
-                    stick_status = int(constants['stick_sec'] * constants['sampl_rate_hz'])
+                    stick_status = int(constants['surface_time'] / constants['sampl_rate_hz'])
                 (new_temp_pos,
                  intersection_point,
                  remaining_distance,
                  is_bottom_edge) = cut_and_bend_spot_edge_out(
                      self, IO_status, base_position, temp_position, remaining_distance, constants
                 )
                 base_position = intersection_point
                 temp_position = new_temp_pos
                 last_vec = temp_position - intersection_point
                 continue
             elif IO_status == IOStatus.BOTTOM_OUT:
                 if stick_status == 0:
-                    stick_status = int(constants['stick_sec'] * constants['sampl_rate_hz'])
+                    stick_status = int(constants['surface_time'] / constants['sampl_rate_hz'])
                 (new_temp_pos,
                  intersection_point,
                  remaining_distance) = cut_and_bend_bottom(
                      self, IO_status, base_position, temp_position, remaining_distance, constants
                 )
                 base_position = intersection_point
                 temp_position = new_temp_pos
                 last_vec = temp_position - intersection_point
                 continue
             elif IO_status in [IOStatus.SURFACE_OUT, IOStatus.EDGE_OUT]:
                 if stick_status == 0:
-                    stick_status = int(constants['stick_sec'] * constants['sampl_rate_hz'])
+                    stick_status = int(constants['surface_time'] / constants['sampl_rate_hz'])
                 (new_temp_pos,
                  intersection_point,
                  remaining_distance) = cut_and_bend_cube(
                      self, IO_status, base_position, temp_position, remaining_distance, constants
                 )
                 base_position = intersection_point
                 temp_position = new_temp_pos
                 last_vec = temp_position - intersection_point
                 continue
             elif IO_status == IOStatus.VERTEX_OUT:
                 if stick_status == 0:
-                    stick_status = int(constants['stick_sec'] * constants['sampl_rate_hz'])
+                    stick_status = int(constants['surface_time'] / constants['sampl_rate_hz'])
                 (intersection_point,
                  new_temp_pos,
                  remaining_distance) = cut_and_bend_vertex(
                      vertex_point, base_position, remaining_distance, constants
                 )
                 base_position = intersection_point
                 temp_position = new_temp_pos
                 last_vec = temp_position - intersection_point
                 continue
     def bottom_edge_mode(self, base_position, last_vec, stick_status, constants):
         """
         底面を這いつつ底面の円周に当たった時の処理。
         後者コードを反映して修正。 polygon_mode から呼ばれる。
         """
         z_floor = constants['spot_bottom_height']
         r_edge  = constants['spot_bottom_r']
         R_spot  = constants['radius']
         candidate_position = base_position + last_vec
         candidate_position[2] = z_floor
         dist2 = candidate_position[0]**2 + candidate_position[1]**2
         radius2 = r_edge**2
         if dist2 > radius2:
             x0, y0 = base_position[0], base_position[1]
             x1, y1 = candidate_position[0], candidate_position[1]
             dx = x1 - x0
