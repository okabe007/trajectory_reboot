diff --git a/core/simulation.py b/core/simulation.py
index a9a9df0..c0ce986 100644
--- a/core/simulation.py
+++ b/core/simulation.py
@@ -108,51 +108,54 @@ class SpermSimulation:
         座標・距離の単位は **mm** で統一。
         """
         # ---- デバッグ：派生値確認 -------------------------------------
         print("[DEBUG] SpermSimulation パラメータ:", self.constants)
 
         # ---- 形状オブジェクト生成 -------------------------------------
         shape = self.constants.get("shape", "cube")
         if shape == "cube":
             shape_obj = CubeShape(self.constants)
         elif shape == "spot":
             shape_obj = SpotShape(self.constants)
         elif shape == "drop":
             shape_obj = DropShape(self.constants)
         elif shape == "ceros":
             shape_obj = CerosShape(self.constants)
         else:
             raise ValueError(f"Unsupported shape: {shape}")
 
         # ---- シミュレーション設定 -------------------------------------
         number_of_sperm  = int(self.constants.get("number_of_sperm", 10))
         number_of_steps  = int(self.constants.get("number_of_steps", 10))
         step_len         = self.constants["step_length"]     # ← mm / step
         seed_val         = self.constants.get("seed_number")
         if seed_val is not None and str(seed_val).lower() != "none":
             try:
-                rng = np.random.default_rng(int(seed_val))
+                seed_int = int(seed_val)
+                # --- 全ての乱数生成を同じシードで制御するため ---
+                np.random.seed(seed_int)
+                rng = np.random.default_rng(seed_int)
             except Exception:
                 rng = np.random.default_rng()
         else:
             rng = np.random.default_rng()
 
         self.trajectory = []   # ← 毎 run() でリセット
 
         # ---- ループ ---------------------------------------------------
         for rep in range(int(sim_repeat)):
             for i in range(number_of_sperm):
 
                 pos = shape_obj.initial_position()     # mm
                 traj = [pos.copy()]
 
                 for j in range(number_of_steps):
                     # ランダム方向の単位ベクトル
                     vec = rng.normal(size=3)
                     vec /= np.linalg.norm(vec) + 1e-12
 
                     pos = pos + vec * step_len         # ★ mm 単位で更新
                     traj.append(pos.copy())
 
                     # デバッグ：最初の一歩だけ確認
                     if rep == 0 and i == 0 and j == 0:
                         print(f"[DEBUG] 1step_disp(mm) = {np.linalg.norm(vec*step_len):.5f}")
