diff --git a/core/simulation.py b/core/simulation.py
index 7bf647d..3d810b6 100644
--- a/core/simulation.py
+++ b/core/simulation.py
@@ -67,50 +67,94 @@ def _egg_position(constants):
         spot_r = constants.get("spot_r", 0)
         spot_bottom_height = constants.get("spot_bottom_height", 0)
         positions = {
             "center": (0, 0, (spot_bottom_height + spot_r) / 2),
             "bottom_center": (0, 0, spot_bottom_height + r),
             "bottom_edge": (
                 math.sqrt(max((spot_r - r) ** 2 - (spot_bottom_height + r) ** 2, 0)),
                 0,
                 spot_bottom_height + r,
             ),
         }
     elif shape == "ceros":
         cx = (constants["x_min"] + constants["x_max"]) / 2
         cy = (constants["y_min"] + constants["y_max"]) / 2
         cz = (constants["z_min"] + constants["z_max"]) / 2
         positions = {"center": (cx, cy, cz), "bottom_center": (cx, cy, cz), "bottom_edge": (cx, cy, cz)}
     else:
         raise RuntimeError(f"Unknown shape '{shape}'")
 
     if loc not in positions:
         raise RuntimeError(f"Invalid egg_localization '{loc}' for shape '{shape}'")
 
     return positions[loc]
 
 
+def _io_check_drop(position: np.ndarray, constants: dict) -> str:
+    """Return 'inside', 'border', or 'outside' for drop shape."""
+    r = constants.get("drop_r", 0.0)
+    limit = constants.get("limit", 1e-9)
+    dist = np.linalg.norm(position)
+    if dist > r + limit:
+        return "outside"
+    elif dist < r - limit:
+        return "inside"
+    else:
+        return "border"
+
+
+def _line_sphere_intersection(p0: np.ndarray, p1: np.ndarray, r: float) -> tuple[np.ndarray, float]:
+    """Return intersection point and remaining distance after hitting the sphere."""
+    d = p1 - p0
+    d_norm = np.linalg.norm(d)
+    if d_norm < 1e-12:
+        return p0.copy(), 0.0
+    d_unit = d / d_norm
+    f = p0
+    a = 1.0
+    b = 2.0 * float(f @ d_unit)
+    c = float(f @ f) - r * r
+    disc = b * b - 4 * a * c
+    if disc < 0:
+        return p0.copy(), 0.0
+    sqrt_disc = math.sqrt(disc)
+    t1 = (-b - sqrt_disc) / (2 * a)
+    t2 = (-b + sqrt_disc) / (2 * a)
+    t_candidates = [t for t in (t1, t2) if t >= 0]
+    if not t_candidates:
+        return p0.copy(), 0.0
+    t = min(t_candidates)
+    intersection = p0 + d_unit * t
+    remaining = max(d_norm - t, 0.0)
+    return intersection, remaining
+
+
+def _reflect(vec: np.ndarray, normal: np.ndarray) -> np.ndarray:
+    """Reflect ``vec`` on plane defined by ``normal``."""
+    return vec - 2.0 * np.dot(vec, normal) * normal
+
+
 class SpermSimulation:
     def __init__(self, constants):
         self.constants = constants
 
         # --- 型安全化：数値パラメータはfloat/intに変換 ---
         float_keys = [
             "spot_angle", "vol", "sperm_conc", "vsl", "deviation", "surface_time",
             "gamete_r", "sim_min", "sampl_rate_hz"
         ]
         int_keys = [
             "sim_repeat"
         ]
         for key in float_keys:
             if key in self.constants and not isinstance(self.constants[key], float):
                 try:
                     self.constants[key] = float(self.constants[key])
                 except Exception:
                     print(f"[WARNING] {key} = {self.constants[key]} をfloat変換できませんでした")
         for key in int_keys:
             if key in self.constants and not isinstance(self.constants[key], int):
                 try:
                     self.constants[key] = int(float(self.constants[key]))
                 except Exception:
                     print(f"[WARNING] {key} = {self.constants[key]} をint変換できませんでした")
         # shape, egg_localization, などはstr型のままでOK
diff --git a/core/simulation.py b/core/simulation.py
index 7bf647d..3d810b6 100644
--- a/core/simulation.py
+++ b/core/simulation.py
@@ -159,52 +203,59 @@ class SpermSimulation:
                 seed_int = int(seed_val)
                 # --- 全ての乱数生成を同じシードで制御するため ---
                 np.random.seed(seed_int)
                 rng = np.random.default_rng(seed_int)
             except Exception:
                 rng = np.random.default_rng()
         else:
             rng = np.random.default_rng()
 
         self.trajectory = []   # ← 毎 run() でリセット
 
         # ---- ループ ---------------------------------------------------
         for rep in range(int(sim_repeat)):
             for i in range(number_of_sperm):
 
                 pos = shape_obj.initial_position()     # mm
                 traj = [pos.copy()]
 
                 # 初期方向
                 vec = rng.normal(size=3)
                 vec /= np.linalg.norm(vec) + 1e-12
 
                 for j in range(number_of_steps):
                     if j > 0:
                         vec = _perturb_direction(vec, self.constants["deviation"], rng)
-
-                    pos = pos + vec * step_len         # ★ mm 単位で更新
+                    candidate = pos + vec * step_len
+                    if shape == "drop":
+                        status = _io_check_drop(candidate, self.constants)
+                        if status == "outside":
+                            intersect, remain = _line_sphere_intersection(pos, candidate, self.constants["drop_r"])
+                            normal = intersect / (np.linalg.norm(intersect) + 1e-12)
+                            vec = _reflect(vec, normal)
+                            candidate = intersect + vec * remain
+                    pos = candidate
                     traj.append(pos.copy())
 
                     if rep == 0 and i == 0 and j == 0:
                         print(f"[DEBUG] 1step_disp(mm) = {np.linalg.norm(vec*step_len):.5f}")
 
                 self.trajectory.append(np.vstack(traj))
 
         print(f"[DEBUG] run完了: sperm={len(self.trajectory)}, steps={number_of_steps}, "
               f"step_len={step_len} mm")
 
 
 
     import matplotlib.pyplot as plt
 
     def plot_trajectories(self, max_sperm=5, save_path=None):
         """
         インスタンスのself.trajectory（リスト of N×3 配列）を可視化
         max_sperm: 表示する精子軌跡の最大本数
         save_path: Noneなら画面表示のみ、パス指定で保存
         """
         import matplotlib.pyplot as plt
         import numpy as np
         import os
 
         trajectories = np.array(self.trajectory)
