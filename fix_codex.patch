diff --git a/core/simulation.py b/core/simulation.py
index 7475072..f366262 100644
--- a/core/simulation.py
+++ b/core/simulation.py
@@ -174,50 +174,122 @@ def _line_sphere_intersection(p0: np.ndarray, p1: np.ndarray, r: float) -> tuple
     d_unit = d / d_norm
     f = p0
     a = 1.0
     b = 2.0 * float(f @ d_unit)
     c = float(f @ f) - r * r
     disc = b * b - 4 * a * c
     if disc < 0:
         return p0.copy(), 0.0
     sqrt_disc = math.sqrt(disc)
     t1 = (-b - sqrt_disc) / (2 * a)
     t2 = (-b + sqrt_disc) / (2 * a)
     t_candidates = [t for t in (t1, t2) if t >= 0]
     if not t_candidates:
         return p0.copy(), 0.0
     t = min(t_candidates)
     intersection = p0 + d_unit * t
     remaining = max(d_norm - t, 0.0)
     return intersection, remaining
 
 
 def _reflect(vec: np.ndarray, normal: np.ndarray) -> np.ndarray:
     """Reflect ``vec`` on plane defined by ``normal``."""
     return vec - 2.0 * np.dot(vec, normal) * normal
 
 
+def polygon_mode(
+    current_pos: np.ndarray,
+    polygon_idx: int,
+    spot_r: float,
+    stick_count: int,
+    deviation: float,
+    spot_angle_rad: float,
+) -> np.ndarray:
+    """Return next vector when tracing the bottom edge polygon.
+
+    When ``stick_count`` falls below 1, ``detach_edge_mode`` is invoked to
+    generate a vector that points inside the spherical cap.
+    """
+
+    if stick_count >= 1:
+        theta_step = 2 * np.pi / 70
+        next_polygon_idx = (polygon_idx + 1) % 70
+        next_theta = next_polygon_idx * theta_step
+
+        x = spot_r * np.sin(spot_angle_rad) * np.cos(next_theta)
+        y = spot_r * np.sin(spot_angle_rad) * np.sin(next_theta)
+        z = spot_r * np.cos(spot_angle_rad)
+
+        next_pos = np.array([x, y, z])
+        next_vector = next_pos - current_pos
+    else:
+        next_vector = detach_edge_mode(
+            current_pos, spot_r, deviation, spot_angle_rad
+        )
+
+    return next_vector
+
+
+def detach_edge_mode(
+    current_pos: np.ndarray,
+    spot_r: float,
+    deviation: float,
+    spot_angle_rad: float,
+) -> np.ndarray:
+    """Return a vector pointing inside the spherical cap with limited spread."""
+
+    sphere_center = np.array([0.0, 0.0, 0.0])
+    base_center = np.array([0.0, 0.0, spot_r * np.cos(spot_angle_rad)])
+
+    local_z = sphere_center - current_pos
+    local_z /= np.linalg.norm(local_z) + 1e-12
+
+    local_x = base_center - current_pos
+    local_x = local_x - np.dot(local_x, local_z) * local_z
+    local_x /= np.linalg.norm(local_x) + 1e-12
+
+    local_y = np.cross(local_z, local_x)
+
+    theta = abs(np.random.normal(0.0, deviation))
+    phi_max = spot_angle_rad - (2 * np.pi / 70)
+    phi = np.random.uniform(0.0, phi_max)
+
+    local_vec = np.array(
+        [
+            np.sin(theta) * np.cos(phi),
+            np.sin(theta) * np.sin(phi),
+            np.cos(theta),
+        ]
+    )
+
+    rotation = np.column_stack([local_x, local_y, local_z])
+    global_vec = rotation @ local_vec
+    global_vec /= np.linalg.norm(global_vec) + 1e-12
+
+    return global_vec
+
+
 class SpermSimulation:
     def __init__(self, constants):
         self.constants = constants
 
         # --- 型安全化：数値パラメータはfloat/intに変換 ---
         float_keys = [
             "spot_angle", "vol", "sperm_conc", "vsl", "deviation", "surface_time",
             "gamete_r", "sim_min", "sampl_rate_hz"
         ]
         int_keys = [
             "sim_repeat"
         ]
         for key in float_keys:
             if key in self.constants and not isinstance(self.constants[key], float):
                 try:
                     self.constants[key] = float(self.constants[key])
                 except Exception:
                     print(f"[WARNING] {key} = {self.constants[key]} をfloat変換できませんでした")
         for key in int_keys:
             if key in self.constants and not isinstance(self.constants[key], int):
                 try:
                     self.constants[key] = int(float(self.constants[key]))
                 except Exception:
                     print(f"[WARNING] {key} = {self.constants[key]} をint変換できませんでした")
         # shape, egg_localization, などはstr型のままでOK
