diff --git a/core/simulation.py b/core/simulation.py
index 1abe548..4ba0923 100644
--- a/core/simulation.py
+++ b/core/simulation.py
@@ -173,51 +173,54 @@ def _io_check_spot(
         if xy_dist < bottom_r - limit:
             if prev_stat in (SpotIO.SPOT_EDGE_OUT, SpotIO.POLYGON_MODE) or stick_status > 0:
                 return SpotIO.POLYGON_MODE
             return SpotIO.SPOT_BOTTOM
 
     return SpotIO.INSIDE
 
 
 def _line_sphere_intersection(p0: np.ndarray, p1: np.ndarray, r: float) -> tuple[np.ndarray, float]:
     """Return intersection point and remaining distance after hitting the sphere."""
     d = p1 - p0
     d_norm = np.linalg.norm(d)
     if d_norm < 1e-12:
         return p0.copy(), 0.0
     d_unit = d / d_norm
     f = p0
     a = 1.0
     b = 2.0 * float(f @ d_unit)
     c = float(f @ f) - r * r
     disc = b * b - 4 * a * c
     if disc < 0:
         return p0.copy(), 0.0
     sqrt_disc = math.sqrt(disc)
     t1 = (-b - sqrt_disc) / (2 * a)
     t2 = (-b + sqrt_disc) / (2 * a)
-    t_candidates = [t for t in (t1, t2) if t >= 0]
+    # Only intersections that lie on the segment between ``p0`` and ``p1``
+    # are valid.  Without this check ``t`` may point to an intersection far
+    # away from the current step which leads to an excessively long vector.
+    t_candidates = [t for t in (t1, t2) if 0 <= t <= d_norm]
     if not t_candidates:
         return p0.copy(), 0.0
     t = min(t_candidates)
     intersection = p0 + d_unit * t
     remaining = max(d_norm - t, 0.0)
     return intersection, remaining
 
 
 def _reflect(vec: np.ndarray, normal: np.ndarray) -> np.ndarray:
     """Reflect ``vec`` on plane defined by ``normal``."""
     return vec - 2.0 * np.dot(vec, normal) * normal
 
 
 def polygon_mode(
     current_pos: np.ndarray,
     polygon_idx: int,
     spot_r: float,
     stick_count: int,
     deviation: float,
     spot_angle_rad: float,
 ) -> np.ndarray:
     """Return next vector when tracing the bottom edge polygon.
 
     When ``stick_count`` falls below 1, ``detach_edge_mode`` is invoked to
     generate a vector that points inside the spherical cap.
