diff --git a/spermsim/main.py b/spermsim/main.py
index 3f2f5b5..b45893a 100644
--- a/spermsim/main.py
+++ b/spermsim/main.py
@@ -782,85 +782,89 @@ def IO_check_cube(temp_position, constants):
         return IOStatus.VERTEX_OUT, vertex_coords
     elif (
         (inside_count == 1 and surface_count == 1 and outside_count == 1) or
         (inside_count == 0 and surface_count == 1 and outside_count == 2)
     ):
         return IOStatus.EDGE_OUT, None
     elif inside_count == 0 and surface_count == 0 and outside_count == 3:
         return IOStatus.SURFACE_OUT, None
     elif inside_count == 0 and surface_count == 3 and outside_count == 0:
         return IOStatus.BORDER, None
     else:
         raise ValueError("Unknown inside/surface/outside combination")
 def IO_check_drop(temp_position, stick_status, constants):
     distance_from_center = LA.norm(temp_position)
     radius = constants['drop_r']
     if distance_from_center > radius + constants['limit']:
         IO_status = IOStatus.SPHERE_OUT
     elif distance_from_center < radius - constants['limit']:
         if stick_status > 0:
             IO_status = IOStatus.TEMP_ON_POLYGON
         else:
             IO_status = IOStatus.INSIDE
     else:
         IO_status = IOStatus.BORDER
     return IO_status
-def IO_check_spot(base_position, temp_position, constants, IO_status):
+def IO_check_spot(base_position, temp_position, constants, IO_status, stick_status=0):
     """
     Spot形状におけるIO判定。
     後者の「うまくいくプログラム」と同一仕様になるように修正。
     """
     radius   = constants['radius']
     bottom_z = constants['spot_bottom_height']
     bottom_r = constants['spot_bottom_r']
     z_tip = temp_position[2]
     r_tip = LA.norm(temp_position)                    
     xy_dist = np.sqrt(temp_position[0]**2 + temp_position[1]**2)
     if z_tip > bottom_z + constants['limit']:
         if r_tip > radius + constants['limit']:
             return IOStatus.SPHERE_OUT
+        elif r_tip < radius - constants['limit']:
+            if stick_status > 0:
+                return IOStatus.TEMP_ON_POLYGON
+            else:
+                return IOStatus.INSIDE
         else:
-#             return "inside"  # ★DEPRECATED
-            return IOStatus.INSIDE
+            return IOStatus.BORDER
     elif z_tip < bottom_z - constants['limit']:
         denom = (temp_position[2] - base_position[2])
         t = (bottom_z - base_position[2]) / denom
         if t < 0 or t > 1:
             return IOStatus.SPHERE_OUT
         intersect_xy = base_position[:2] + t*(temp_position[:2] - base_position[:2])
         dist_xy = np.sqrt(intersect_xy[0]**2 + intersect_xy[1]**2)
         if dist_xy < bottom_r + constants['limit']:
             return IOStatus.BOTTOM_OUT
         else:
             return IOStatus.SPHERE_OUT
     elif bottom_z - constants['limit'] < z_tip < bottom_z + constants['limit']:
         if xy_dist > bottom_r + constants['limit']:
             return IOStatus.SPOT_EDGE_OUT
         elif abs(xy_dist - bottom_r) <= constants['limit']:
             return IOStatus.BORDER
         elif xy_dist < bottom_r - constants['limit']:
-            if IO_status in [IOStatus.SPOT_EDGE_OUT, IOStatus.POLYGON_MODE]:
+            if IO_status in [IOStatus.SPOT_EDGE_OUT, IOStatus.POLYGON_MODE] or stick_status > 0:
                 return IOStatus.POLYGON_MODE
             else:
                 return IOStatus.SPOT_BOTTOM
     return IOStatus.INSIDE
 class SpermSimulation:
     def initialize_thickness(self):
         for j in range(self.number_of_sperm):
             for i in range(self.number_of_steps):
                 self.vec_thickness_2d[j, i] = 0.4
                 self.vec_thickness_3d[j, i] = 1.5
 
     
     def __init__(self, constants, visualizer, simulation_data):
 
         self.constants = constants  # ✅ 最初に設定
 
         self.number_of_sperm = self.constants["number_of_sperm"]
         self.number_of_steps = self.constants["number_of_steps"]
 
         self.vec_thickness_2d = np.zeros((self.number_of_sperm, self.number_of_steps))
         self.vec_thickness_3d = np.zeros((self.number_of_sperm, self.number_of_steps))
         self.initialize_thickness()
 
         self.visualizer = visualizer
         self.simulation = simulation_data
diff --git a/spermsim/main.py b/spermsim/main.py
index 3f2f5b5..b45893a 100644
--- a/spermsim/main.py
+++ b/spermsim/main.py
@@ -1066,59 +1070,59 @@ class SpermSimulation:
         if self.n_stop is not None and not np.isnan(self.n_stop):
             max_steps = int(self.n_stop)
         else:
             max_steps = self.number_of_steps
         while i < self.number_of_steps:
             max_safety_loops = 1000  # 無限ループ防止
 
             if shape in ["cube", "ceros"]:
                 new_IO_status, vertex_point = IO_check_cube(temp_position, constants)
             elif shape == "drop":
                 new_IO_status = IO_check_drop(temp_position, stick_status, constants)
                 vertex_point = None
                 if new_IO_status == IOStatus.BORDER:
                     vec = temp_position - base_position
                     vec_length = np.linalg.norm(vec)
                     if vec_length > constants['limit']:
                         adjusted_vec = vec * 0.99
                         temp_position = base_position + adjusted_vec
                         new_IO_status = IO_check_drop(temp_position, stick_status, constants)
                     if new_IO_status == IOStatus.BORDER:
                         raise RuntimeError("drop: rethink logic for border")
             elif shape == "spot":
                 prev_stat = self.prev_IO_status[j]
                 if prev_stat is None:
                     prev_stat = "none"
-                new_IO_status = IO_check_spot(base_position, temp_position, constants, prev_stat)
+                new_IO_status = IO_check_spot(base_position, temp_position, constants, prev_stat, stick_status)
                 vertex_point = None
                 if new_IO_status == IOStatus.BORDER:
                     vec = temp_position - base_position
                     vec_length = np.linalg.norm(vec)
                     if vec_length > constants['limit']:
                         adjusted_vec = vec * 0.99
                         temp_position = base_position + adjusted_vec
-                        new_IO_status = IO_check_spot(base_position, temp_position, constants, prev_stat)
+                        new_IO_status = IO_check_spot(base_position, temp_position, constants, prev_stat, stick_status)
                     if new_IO_status == IOStatus.BORDER:
                         raise RuntimeError("rethink logic 3")
             else:
                 new_IO_status = "inside"
                 vertex_point = None
             prev_stat = self.prev_IO_status[j]
             if prev_stat in [IOStatus.TEMP_ON_EDGE, IOStatus.TEMP_ON_SURFACE] and (stick_status > 0):
                 if new_IO_status in [
                     IOStatus.INSIDE,
                     IOStatus.TEMP_ON_POLYGON,
                     IOStatus.TEMP_ON_SURFACE,
                     IOStatus.TEMP_ON_EDGE,
                     IOStatus.SPOT_BOTTOM,
             ]:
                     new_IO_status = prev_stat
                     vertex_point = None
             IO_status = new_IO_status
             self.prev_IO_status[j] = IO_status
             if remaining_distance < 0:
                 raise RuntimeError("rd<0")
             if IO_status in [
                 IOStatus.INSIDE,
                 IOStatus.TEMP_ON_SURFACE,
                 IOStatus.TEMP_ON_EDGE,
                 IOStatus.SPOT_BOTTOM,
diff --git a/spermsim/main.py b/spermsim/main.py
index 3f2f5b5..b45893a 100644
--- a/spermsim/main.py
+++ b/spermsim/main.py
@@ -2224,33 +2228,33 @@ def main():
     conn.close()
     print(f"実行時間: {time.time() - start_time:.2f}秒")
 
 
 if __name__ == "__main__":
     main()
 
 
 def _detect_boundary(shape, base_position, temp_position, stick_status, constants, prev_stat):
     """shape に応じて IOStatus と vertex_point を返す純粋関数
     戻り値: (IOStatus, vertex_point, temp_position)
     """
     if shape in ("cube", "ceros"):
         status, vertex = IO_check_cube(temp_position, constants)
         return status, vertex, temp_position
 
     if shape == "drop":
         status = IO_check_drop(temp_position, stick_status, constants)
         if status == IOStatus.BORDER:
             vec = temp_position - base_position
             temp_position = base_position + vec * 0.99
             status = IO_check_drop(temp_position, stick_status, constants)
         return status, None, temp_position
 
     if shape == "spot":
-        status = IO_check_spot(base_position, temp_position, constants, prev_stat)
+        status = IO_check_spot(base_position, temp_position, constants, prev_stat, stick_status)
         if status == IOStatus.BORDER:
             vec = temp_position - base_position
             temp_position = base_position + vec * 0.99
-            status = IO_check_spot(base_position, temp_position, constants, prev_stat)
+            status = IO_check_spot(base_position, temp_position, constants, prev_stat, stick_status)
         return status, None, temp_position
 
     return IOStatus.INSIDE, None, temp_position
